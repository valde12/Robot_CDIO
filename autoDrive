#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, GyroSensor
from pybricks.robotics import DriveBase
from pybricks.tools import wait
import cv2
import numpy as np

# Initialize the EV3 Brick
ev3 = EV3Brick()

# Initialize the motors connected to the wheels
left_motor = Motor(Port.A)
right_motor = Motor(Port.C)

# Create a DriveBase object with the initialized motors
# Adjust the wheel diameter and axle track according to your robot design
robot = DriveBase(left_motor, right_motor, wheel_diameter=40, axle_track=110)
robot.settings(straight_speed=200, straight_acceleration=100, turn_rate=100)

gyro_sensor = GyroSensor(Port.S1)

# Function to simulate getting the ball position
def get_ball_position():
    # Simulate getting ball position relative to the center of the screen
    ball_x = np.random.randint(-50, 50)  # Random x-coordinate relative to the center
    ball_y = np.random.randint(-50, 50)  # Random y-coordinate relative to the center
    return ball_x, ball_y

# Function to simulate driving towards the ball
def drive_towards_ball(target_x, current_x, robot_speed, angle_correction):
    if target_x is not None:
        # Calculate the error between the target and current positions
        error = target_x - current_x

        # Adjust the steering based on the error (proportional control)
        correction = angle_correction * error

        # Simulate driving the robot with the adjusted steering
        print("Driving towards ball...")
        print(f"Target X: {target_x}, Current X: {current_x}, Correction: {correction}")
        # Code to actually drive the robot here (not implemented in simulation)

# Main program
robot_speed = 500
drive_distance = 1000

# Simulate driving towards the ball for the specified distance
while True:  # Simulate driving for a certain distance (infinite loop for simulation)
    # Get the current ball position (simulate)
    ball_x, ball_y = get_ball_position()

    # Simulate driving towards the ball
    drive_towards_ball(ball_x, 0, robot_speed, 1)

    # Simulate stopping the robot after reaching the specified distance
    if abs(ball_x) < 10:  # Stop when close enough to the ball (for simulation)
        print("Reached the ball!")
        break

# Turn 180 degrees (not simulated)
print("Turning 180 degrees...")
# Code to turn the robot here (not implemented in simulation)

# Simulate driving towards the ball again for the specified distance
while True:  # Simulate driving for a certain distance (infinite loop for simulation)
    # Get the current ball position (simulate)
    ball_x, ball_y = get_ball_position()

    # Simulate driving towards the ball
    drive_towards_ball(ball_x, 0, robot_speed, 1)

    # Simulate stopping the robot after reaching the specified distance
    if abs(ball_x) < 10:  # Stop when close enough to the ball (for simulation)
        print("Reached the ball again!")
        break

# Stop the robot (not simulated)
print("Robot stopped.")
